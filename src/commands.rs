use crate::config::{self, Account, Config};
use crate::error::{GitSwitchError, Result};
use crate::ssh;
use crate::utils;
use crate::git; // Added import
use std::fs;
use std::io::{self, Write};
use std::path::PathBuf;

pub fn add_account(
    config: &mut Config,
    name: &str,
    username: &str,
    email: &str,
    ssh_key_path_opt: Option<PathBuf>,
) -> Result<()> {
    if config.accounts.contains_key(name) {
        return Err(GitSwitchError::AccountExists {
            name: name.to_string(),
        });
    }

    let ssh_key_path_str = if let Some(custom_path) = ssh_key_path_opt.as_ref() { // Borrow for path manipulation
        custom_path
            .to_str()
            .ok_or_else(|| GitSwitchError::InvalidPath(custom_path.clone()))?
            .to_string()
    } else {
        format!("~/.ssh/id_rsa_{}", name.replace(" ", "_").to_lowercase())
    };

    let expanded_key_path = utils::expand_path(&ssh_key_path_str)?;

    utils::ensure_parent_dir_exists(&expanded_key_path)?;

    if ssh_key_path_opt.is_none() && !expanded_key_path.exists() {
        // Only generate if no custom path is given AND the default path doesn't exist.
        // If custom path is given, user is responsible for the key.
        // If default path exists, assume user wants to use it.
        println!("Generating SSH key at: {}", expanded_key_path.display());
        ssh::generate_ssh_key(&expanded_key_path)?;
    } else if ssh_key_path_opt.is_some() && !expanded_key_path.exists() {
        return Err(GitSwitchError::SshKeyGeneration{
            message: format!("Specified SSH key path does not exist: {}", expanded_key_path.display())
        });
    } else if expanded_key_path.exists() {
        println!("Using existing SSH key at: {}", expanded_key_path.display());
    }

    let account = Account {
        name: name.to_string(),
        username: username.to_string(),
        email: email.to_string(),
        ssh_key_path: ssh_key_path_str.clone(),
    };

    config.accounts.insert(name.to_string(), account);
    config::save_config(config)?;

    ssh::update_ssh_config(name, &ssh_key_path_str)?;

    println!("‚úÖ Account '{}' added successfully!", name);
    // Display public key if it was just generated by us, or if it's a new account with a default path key
    // Corrected logic: ssh_key_path_opt.is_none() means we generated it or used default.
    // !expanded_key_path.exists() before generation means we created it.
    // Check if the public key file actually exists before trying to display it.
    if ssh_key_path_opt.is_none() && expanded_key_path.with_extension("pub").exists() {
        println!("\nüîë Here is your public SSH key to add to GitHub/GitLab etc.:");
        println!("--------------------------------------------------");
        ssh::display_public_key(&expanded_key_path)?;
        println!("--------------------------------------------------");
        println!(
            "Copy this key and add it to your Git provider: https://github.com/settings/keys"
        );
    }
    Ok(())
}

pub fn list_accounts(config: &Config) -> Result<()> {
    if config.accounts.is_empty() {
        println!("No saved accounts.");
        return Ok(());
    }
    println!("üîπ Saved Git Accounts:");
    println!("--------------------------------------------------------------------------------------------");
    println!("{:<20} | {:<25} | {:<30} | {:<40}", "Account Name", "Git Username", "Email", "SSH Key Path");
    println!("--------------------------------------------------------------------------------------------");
    for acc in config.accounts.values() {
        println!("{:<20} | {:<25} | {:<30} | {:<40}", acc.name, acc.username, acc.email, acc.ssh_key_path);
    }
    println!("--------------------------------------------------------------------------------------------");
    Ok(())
}

// Renamed from `use_account` to `handle_account_subcommand` to reflect its role for `git switch account <name>`
// This function sets the Git identity for the CURRENT REPOSITORY.
pub fn handle_account_subcommand(config: &Config, name_or_username: &str) -> Result<()> {
    let account = config.accounts.get(name_or_username)
        .or_else(|| {
            config.accounts.values().find(|acc| acc.username == name_or_username)
        })
        .cloned()
        .ok_or_else(|| GitSwitchError::AccountNotFound { name: name_or_username.to_string() })?;

    if !git::is_git_repository()? { // Replaced PathBuf check
        return Err(GitSwitchError::NotInGitRepository);
    }

    println!("Setting Git identity for current repository to account: \'{}\'", account.name);
    utils::run_command("git", &["config", "user.name", &account.username], None)?;
    utils::run_command("git", &["config", "user.email", &account.email], None)?;
    
    let expanded_ssh_key_path = utils::expand_path(&account.ssh_key_path)?;
    let ssh_command = format!("ssh -i {} -o IdentitiesOnly=yes", expanded_ssh_key_path.to_string_lossy());
    utils::run_command("git", &["config", "core.sshCommand", &ssh_command], None)?;
    
    println!("‚úÖ Git user.name, user.email, and core.sshCommand set locally for this repository.");

    println!("üîÑ Ensuring SSH agent is running and key \'{}\' is added...", expanded_ssh_key_path.display());
    let key_path_str = expanded_ssh_key_path.to_str()
        .ok_or_else(|| GitSwitchError::InvalidPath(expanded_ssh_key_path.clone()))?;
    match ssh::add_ssh_key(key_path_str) {
        Ok(true) => {
            println!("üîë SSH key successfully added/confirmed in agent.");
        }
        Ok(false) => {
             eprintln!("‚ö†Ô∏è SSH key for \'{}\' could not be added to the agent. It might already be added, or the agent might not be running. Please check agent status or add manually if needed.", account.name);
        }
        Err(e) => {
            eprintln!("Error adding SSH key \'{}\' to agent: {}. You may need to add it manually.", expanded_ssh_key_path.display(), e);
        }
    }
    Ok(())
}

// New function to handle `git switch use <name>` for GLOBAL git config changes.
pub fn use_account_globally(config: &Config, name_or_username: &str) -> Result<()> {
    let account = config.accounts.get(name_or_username)
        .or_else(|| {
            config.accounts.values().find(|acc| acc.username == name_or_username)
        })
        .cloned()
        .ok_or_else(|| GitSwitchError::AccountNotFound { name: name_or_username.to_string() })?;

    println!("Setting GLOBAL Git identity to account: \'{}\'", account.name);
    utils::run_command("git", &["config", "--global", "user.name", &account.username], None)?;
    utils::run_command("git", &["config", "--global", "user.email", &account.email], None)?;

    // For global, setting core.sshCommand might be too broad. 
    // Users typically manage global SSH via ~/.ssh/config.
    // However, if we want `git-switch use` to also make SSH work globally for that account,
    // we might need to ensure the SSH config is correctly set up for the chosen account\'s key.
    // The `add_account` already calls `ssh::update_ssh_config`.
    // We should ensure `ssh::add_ssh_key` is called for the global context too.
    
    let expanded_ssh_key_path = utils::expand_path(&account.ssh_key_path)?;
    println!("‚úÖ Global Git user.name and user.email set.");
    println!("Ensure your SSH agent is configured to use the key: {}", expanded_ssh_key_path.display());
    println!("Attempting to add SSH key to agent...");

    let key_path_str = expanded_ssh_key_path.to_str()
        .ok_or_else(|| GitSwitchError::InvalidPath(expanded_ssh_key_path.clone()))?;
    match ssh::add_ssh_key(key_path_str) {
        Ok(true) => {
            println!("üîë SSH key \'{}\' successfully added/confirmed in agent.", expanded_ssh_key_path.display());
        }
        Ok(false) => {
             eprintln!("‚ö†Ô∏è SSH key for \'{}\' could not be added to the agent. It might already be added, or the agent might not be running. Please check agent status or add manually if needed.", account.name);
        }
        Err(e) => {
            eprintln!("Error adding SSH key \'{}\' to agent: {}. You may need to add it manually.", expanded_ssh_key_path.display(), e);
        }
    }
    println!("Hint: For SSH connections, ensure your remote URLs are in SSH format (e.g., git@github.com:user/repo.git).");
    Ok(())
}

pub fn remove_account(config: &mut Config, name: &str, no_prompt: bool) -> Result<()> {
    let account_to_remove = config.accounts.get(name).cloned().ok_or_else(|| GitSwitchError::AccountNotFound { name: name.to_string() })?;

    if !no_prompt {
        print!("Are you sure you want to remove account '{}' and its SSH key association? (y/n): ", name);
        io::stdout().flush().map_err(GitSwitchError::Io)?;
        let mut response = String::new();
        io::stdin().read_line(&mut response).map_err(GitSwitchError::Io)?;
        if response.trim().to_lowercase() != "y" {
            println!("Aborted removal.");
            return Ok(());
        }
    }

    if config.accounts.remove(name).is_some() {
        config::save_config(config)?;
        println!("‚úÖ Account '{}' removed from configuration.", name);

        let mut delete_key = no_prompt;
        if !no_prompt {
            print!("Do you want to delete the associated SSH key file(s) for '{}' (path: '{}')? (y/n): ", account_to_remove.name, account_to_remove.ssh_key_path);
            io::stdout().flush().map_err(GitSwitchError::Io)?;
            let mut key_response = String::new();
            io::stdin().read_line(&mut key_response).map_err(GitSwitchError::Io)?;
            if key_response.trim().to_lowercase() == "y" {
                delete_key = true;
            }
        }

        if delete_key {
            match utils::expand_path(&account_to_remove.ssh_key_path) {
                Ok(expanded_path) => {
                    if expanded_path.exists() {
                        if fs::remove_file(&expanded_path).is_ok() {
                            println!("üîë SSH private key file '{}' deleted.", expanded_path.display());
                        } else {
                            eprintln!("‚ö†Ô∏è Warning: Failed to delete SSH private key file {}. Check permissions.", expanded_path.display());
                        }
                    }
                    let pub_key_path = expanded_path.with_extension("pub");
                    if pub_key_path.exists() {
                        if fs::remove_file(&pub_key_path).is_ok() {
                            println!("üîë SSH public key file '{}' deleted.", pub_key_path.display());
                        } else {
                            eprintln!("‚ö†Ô∏è Warning: Failed to delete SSH public key file {}. Check permissions.", pub_key_path.display());
                        }
                    }
                }
                Err(e) => {
                    eprintln!("‚ö†Ô∏è Warning: Could not expand SSH key path '{}' for deletion: {}. Manual deletion might be required.", account_to_remove.ssh_key_path, e);
                }
            }
        }

        match ssh::remove_ssh_config_entry(name) {
            Ok(_) => println!("‚ÑπÔ∏è SSH config entry for '{}' processed for removal.", name),
            Err(e) => eprintln!("‚ö†Ô∏è Warning: Failed to update SSH config while removing account '{}': {}. Manual check of ~/.ssh/config recommended.", name, e),
        }
        Ok(())
    } else {
        Err(GitSwitchError::AccountNotFound { name: name.to_string() })
    }
}

pub fn handle_remote_subcommand(https: bool, ssh: bool) -> Result<()> {
    if !git::is_git_repository()? { // Replaced PathBuf check
        return Err(GitSwitchError::NotInGitRepository);
    }

    let remote_url = match git::get_git_remote_url("origin") {
        Ok(url) => url,
        Err(GitSwitchError::GitRemoteUrlNotFound { remote_name }) => {
            // If the error is specifically GitRemoteUrlNotFound, we can provide a more specific message
            // or handle it as "no URL configured" if that's the desired behavior.
            // For now, let's re-wrap it or return a specific error.
            // This example assumes you want to propagate it.
            // If you want to treat it as "None", you'd change the logic here.
            return Err(GitSwitchError::GitRemoteUrlNotFound { remote_name });
        }
        Err(e) => return Err(e), // Propagate other errors
    };
    
    println!("Current remote URL for 'origin': {}", remote_url);

    let new_url: String = if https {
        if remote_url.starts_with("https://") {
            println!("Remote is already HTTPS.");
            return Ok(());
        }
        if remote_url.starts_with("git@") {
            let parts_after_at: Vec<&str> = remote_url.splitn(2, '@').collect();
            if parts_after_at.len() < 2 {
                return Err(GitSwitchError::Other(format!("Could not parse SSH URL (git@): {}", remote_url)));
            }
            let host_and_path: Vec<&str> = parts_after_at[1].splitn(2, ':').collect();
            if host_and_path.len() < 2 {
                return Err(GitSwitchError::Other(format!("Could not parse SSH URL (git@): {}", remote_url)));
            }
            let host = host_and_path[0];
            let path = host_and_path[1];

            if host.contains("ssh.dev.azure.com") {
                let path_parts: Vec<&str> = path.split('/').collect(); 
                if path_parts.len() == 4 { // v3/ORG/PROJECT/REPO
                    format!("https://dev.azure.com/{}/{}/_git/{}", path_parts[1], path_parts[2], path_parts[3])
                } else {
                    return Err(GitSwitchError::Other(format!("Could not parse Azure SSH URL path: {}", path)));
                }
            } else { 
                format!("https://{}/{}", host, path)
            }
        } else if remote_url.starts_with("ssh://git@") {
            let host_path_str = remote_url.trim_start_matches("ssh://git@");
            let parts: Vec<&str> = host_path_str.splitn(2, ':').collect(); 
            if parts.len() == 2 { 
                 format!("https://{}/{}", parts[0], parts[1])
            } else {
                 let parts_slash: Vec<&str> = host_path_str.splitn(2, '/').collect(); 
                 if parts_slash.len() == 2 {
                    format!("https://{}/{}", parts_slash[0], parts_slash[1])
                 } else {
                    return Err(GitSwitchError::Other(format!("Could not parse SSH URL (ssh://git@): {}", remote_url)));
                 }
            }
        } else {
            return Err(GitSwitchError::Other(format!("Cannot convert unrecognized SSH URL format to HTTPS: {}", remote_url)));
        }
    } else if ssh {
        if remote_url.starts_with("git@") || remote_url.starts_with("ssh://") {
            println!("Remote is already SSH.");
            return Ok(());
        }
        if remote_url.starts_with("https://") {
            let path_after_https = remote_url.trim_start_matches("https://");
            let domain_and_project_path: Vec<&str> = path_after_https.splitn(2, '/').collect();
            if domain_and_project_path.len() < 2 {
                return Err(GitSwitchError::Other(format!("Could not parse HTTPS URL: {}", remote_url)));
            }
            let domain = domain_and_project_path[0];
            let project_path = domain_and_project_path[1];
            
            if domain.contains("dev.azure.com") || domain.contains(".visualstudio.com") {
                let org = if domain.contains(".visualstudio.com") {
                    domain.split('.').next().unwrap_or_default().to_string()
                } else { 
                    project_path.split('/').next().unwrap_or_default().to_string()
                };
                let path_parts: Vec<&str> = project_path.split('/').collect();
                
                if domain.contains("dev.azure.com") && path_parts.len() >= 4 && path_parts[2] == "_git" {
                    let project_name = path_parts[1];
                    let repo_name = path_parts[3];
                    format!("git@ssh.dev.azure.com:v3/{}/{}/{}", org, project_name, repo_name)
                } else if domain.contains(".visualstudio.com") && path_parts.len() >= 3 && path_parts[1] == "_git" {
                    // For ORG.visualstudio.com/PROJECT/_git/REPO, path_parts[0] is PROJECT, path_parts[2] is REPO
                    let project_name = path_parts[0];
                    let repo_name = path_parts[2];
                    format!("git@ssh.dev.azure.com:v3/{}/{}/{}", org, project_name, repo_name)
                } else {
                    return Err(GitSwitchError::Other(format!("Could not parse Azure HTTPS URL parts for SSH conversion: {}", remote_url)));
                }
            } else { 
                format!("git@{}:{}", domain, project_path)
            }
        } else {
            return Err(GitSwitchError::Other(format!("Cannot convert unrecognized URL format to SSH: {}", remote_url)));
        }
    } else {
        println!("No action specified. Use --https or --ssh.");
        return Ok(());
    };

    if new_url == remote_url {
        println!("No change needed for remote URL.");
    } else {
        git::update_git_remote("origin", &new_url)?; // Replaced manual command
        println!("‚úÖ Remote 'origin' URL updated to: {}", new_url);
    }
    Ok(())
}

pub fn handle_whoami_subcommand(config: &Config) -> Result<()> {
    println!("üîé Current Git Identity & Repository Status:");
    println!("------------------------------------------");

    let in_git_repo = git::is_git_repository()?; // Replaced PathBuf check
    let mut active_account_name: Option<String> = None;

    if in_git_repo {
        let local_user_name_opt = utils::run_command_with_output("git", &["config", "user.name"], None)
            .ok().and_then(|o| String::from_utf8(o.stdout).ok().map(|s| s.trim().to_string()).filter(|s| !s.is_empty()));
        let local_user_email_opt = utils::run_command_with_output("git", &["config", "user.email"], None)
            .ok().and_then(|o| String::from_utf8(o.stdout).ok().map(|s| s.trim().to_string()).filter(|s| !s.is_empty()));

        if let (Some(name), Some(email)) = (&local_user_name_opt, &local_user_email_opt) {
            println!("üë§ Local Repository Identity: {} <{}>", name, email);
            // Corrected string comparison:
            if let Some(acc) = config.accounts.values().find(|acc| acc.username == *name && acc.email == *email) {
                println!("   ‚îî‚îÄ‚îÄ Linked to git-switch account: '{}'", acc.name);
                active_account_name = Some(acc.name.clone());
            }
        } else {
            println!("üë§ Local Repository Identity: Not set.");
        }

        let ssh_command_opt = utils::run_command_with_output("git", &["config", "core.sshCommand"], None)
            .ok().and_then(|o| String::from_utf8(o.stdout).ok().map(|s| s.trim().to_string()).filter(|s| !s.is_empty()));
        
        if let Some(cmd) = ssh_command_opt { // Check if ssh_command_opt is Some
            println!("üîë Local SSH Command (core.sshCommand): {}", cmd);
            if let Some(key_path_part) = cmd.split(" -i ").nth(1) {
                if let Some(key_path_str) = key_path_part.split(' ').next() {
                    if let Ok(expanded_key_path) = utils::expand_path(key_path_str) {
                        println!("   ‚îî‚îÄ‚îÄ Deduced SSH Key Path: {}", expanded_key_path.display());
                        if active_account_name.is_none() {
                             if let Some(acc) = config.accounts.values().find(|acc| utils::expand_path(&acc.ssh_key_path).ok() == Some(expanded_key_path.clone())) {
                                println!("   ‚îî‚îÄ‚îÄ Linked to git-switch account: '{}' (by SSH key)", acc.name);
                                active_account_name = Some(acc.name.clone());
                            }
                        }
                    }
                }
            } // Removed the problematic 'else' that caused syntax error
        } else { // This 'else' corresponds to `if let Some(cmd) = ssh_command_opt`
            println!("üîë Local SSH Command (core.sshCommand): Not set.");
        }

        match git::get_git_remote_url("origin") { // Replaced manual command
            Ok(url) => { // Changed from Ok(Some(url)) to Ok(url)
                println!("üì° Remote 'origin' URL: {}", url);
                if url.starts_with("https://") { println!("   ‚îî‚îÄ‚îÄ Protocol: HTTPS"); }
                else if url.starts_with("git@") || url.starts_with("ssh://") { println!("   ‚îî‚îÄ‚îÄ Protocol: SSH"); }
                else { println!("   ‚îî‚îÄ‚îÄ Protocol: Unknown or other"); }
            }
            Err(GitSwitchError::GitRemoteUrlNotFound { .. }) => println!("üì° Remote 'origin': No URL configured."), // Specific handling
            Err(_) => println!("üì° Remote 'origin': Could not retrieve URL (remote may not exist or other git error)."),
        }
    } else {
        println!("Not inside a Git repository. Showing global and available account information only.");
    }

    println!("---");
    let global_user_name_opt = utils::run_command_with_output("git", &["config", "--global", "user.name"], None)
        .ok().and_then(|o| String::from_utf8(o.stdout).ok().map(|s| s.trim().to_string()).filter(|s| !s.is_empty()));
    let global_user_email_opt = utils::run_command_with_output("git", &["config", "--global", "user.email"], None)
        .ok().and_then(|o| String::from_utf8(o.stdout).ok().map(|s| s.trim().to_string()).filter(|s| !s.is_empty()));

    if let (Some(name), Some(email)) = (global_user_name_opt, global_user_email_opt) { // Use the new _opt variables
        println!("üåç Global Git Identity: {} <{}>", name, email);
        if active_account_name.is_none() { 
            // Corrected string comparison:
            if let Some(acc) = config.accounts.values().find(|acc| acc.username == name && acc.email == email) {
                println!("   ‚îî‚îÄ‚îÄ Matches git-switch account: '{}' (global default)", acc.name);
                active_account_name = Some(acc.name.clone());
            }
        }
    } else {
        println!("üåç Global Git Identity: Not set.");
    }
    
    if let Some(name) = active_account_name {
        println!("‚öôÔ∏è Effective git-switch Account: '{}'", name);
    } else {
        println!("‚öôÔ∏è Effective git-switch Account: None explicitly active or matched.");
    }
    println!("------------------------------------------");
    Ok(())
}

pub fn handle_auth_test_subcommand(config: &Config) -> Result<()> {
    let mut key_to_test: Option<PathBuf> = None;
    let mut _associated_account_name: Option<String> = None; // Prefix with _ to silence unused warning if it's truly not used later for logic

    if git::is_git_repository()? { // Replaced PathBuf check
        if let Ok(output) = utils::run_command_with_output("git", &["config", "core.sshCommand"], None) {
            let ssh_cmd = String::from_utf8_lossy(&output.stdout).trim().to_string();
            if !ssh_cmd.is_empty() {
                if let Some(key_path_part) = ssh_cmd.split(" -i ").nth(1) {
                    if let Some(key_path_str) = key_path_part.split(' ').next() {
                        if let Ok(expanded_path) = utils::expand_path(key_path_str) {
                            key_to_test = Some(expanded_path);
                        }
                    }
                }
            }
        }
    }
    
    if let Some(ref key_path_to_test_expanded) = key_to_test {
        if let Some(acc) = config.accounts.values().find(|acc| utils::expand_path(&acc.ssh_key_path).ok() == Some(key_path_to_test_expanded.clone())) {
            _associated_account_name = Some(acc.name.clone()); // Assign to the prefixed variable
        }
        println!("‚ÑπÔ∏è Using SSH key from current repository's Git configuration: {}", key_path_to_test_expanded.display());
        if let Some(acc_name) = &_associated_account_name { // Use the prefixed variable
             println!("   (Associated with git-switch account: {})", acc_name);
        }
    } else if !config.accounts.is_empty() {
        println!("No SSH key configured for the current repository. Please select an account to test:");
        let account_names: Vec<&String> = config.accounts.keys().collect();
        for (i, name) in account_names.iter().enumerate() {
            println!("{}. {}", i + 1, name);
        }
        print!("Enter number of account to test (or 0 to test default SSH): ");
        io::stdout().flush().map_err(GitSwitchError::Io)?;
        let mut input = String::new();
        io::stdin().read_line(&mut input).map_err(GitSwitchError::Io)?;
        match input.trim().parse::<usize>() {
            Ok(num) if num > 0 && num <= account_names.len() => {
                let selected_account_name = account_names[num - 1];
                if let Some(account) = config.accounts.get(selected_account_name) {
                    key_to_test = utils::expand_path(&account.ssh_key_path).ok();
                    _associated_account_name = Some(account.name.clone()); // Assign to the prefixed variable
                    if let Some(ref kt) = key_to_test {
                        println!("‚ÑπÔ∏è Selected account '{}', testing with key: {}", selected_account_name, kt.display());
                    } else {
                        println!("‚ö†Ô∏è Could not resolve SSH key path for account '{}'. Testing default SSH.", selected_account_name);
                    }
                }
            }
            Ok(0) => println!("‚ÑπÔ∏è Testing default SSH authentication (no specific key)."),
            _ => {
                println!("Invalid selection. Testing default SSH authentication.");
            }
        }
    } else {
        println!("‚ÑπÔ∏è No SSH key in repository config and no git-switch accounts configured. Testing default SSH authentication.");
    }

    let hosts_to_test = ["git@github.com", "git@gitlab.com"];
    println!("\nüß™ Attempting SSH authentication test...");

    for host_spec in hosts_to_test.iter() {
        println!("\nTesting connection to {}...", host_spec);
        let mut args_vec: Vec<String> = vec!["-o", "StrictHostKeyChecking=no", "-o", "BatchMode=yes"].into_iter().map(String::from).collect();
        
        let key_path_str_temp: Option<String>; 
        if let Some(ref key) = key_to_test {
            args_vec.push("-i".to_string());
            key_path_str_temp = Some(key.to_string_lossy().into_owned());
            args_vec.push(key_path_str_temp.as_ref().unwrap().clone());
        }
        args_vec.push("-T".to_string());
        args_vec.push(host_spec.to_string());

        let args_str_slice: Vec<&str> = args_vec.iter().map(AsRef::as_ref).collect();
        
        match utils::run_command_with_full_output("ssh", &args_str_slice, None) {
            Ok(output) => {
                let stdout = String::from_utf8_lossy(&output.stdout);
                let stderr = String::from_utf8_lossy(&output.stderr);

                if output.status.success() || stderr.contains("successfully authenticated") || stdout.contains("successfully authenticated") {
                    println!("‚úÖ Successfully authenticated with {}. Full response (stderr usually has the auth message):\n--- Stderr ---\n{}
--- Stdout ---\n{}
--------------- ‚úì", host_spec, stderr.trim(), stdout.trim());
                } else {
                    println!("‚ùå Authentication failed with {}. Exit code: {}. Full response:\n--- Stderr ---\n{}
--- Stdout ---
{}
--------------- ‚úó", host_spec, output.status, stderr.trim(), stdout.trim());
                    if stderr.contains("Permission denied") {
                        println!("   Hint: 'Permission denied' usually means the SSH key is not authorized on the server.");
                    }
                }
            }
            Err(e) => {
                println!("‚ùå Failed to execute SSH command for {}: {}", host_spec, e);
            }
        }
    }
    Ok(())
}
